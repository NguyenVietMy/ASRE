---
alwaysApply: true
---

# Clean DDD Enforcement Rule (Auth Module + Whole Project)

The login flow has been refactored to follow strict DDD boundaries. All future code must follow the exact same architectural rules.

Cursor must apply this to all future generations AND fix any existing violations in files when requested.

## 1. Layering Rules (Do NOT violate these)

### Domain Layer (domain/)

- Pure business logic only.
- No Spring imports.
- No HttpServletRequest/Response.
- No annotations except Lombok.
- No JPA or database annotations.
- No DTOs or JSON annotations.
- Domain may contain:
  - Aggregates
  - Value objects
  - Domain events
  - Repository interfaces
  - Domain result objects (e.g., AuthResult)
  - Domain commands (e.g., LoginCommand)

### Application Layer (application/)

- Contains use-case services.
- Accepts only domain objects (commands, aggregates).
- Returns only domain objects (results, aggregates).
- Must NOT accept or return:
  - DTOs
  - JPA entities
  - HttpServletRequest/Response
  - Cookies
  - JSON
  - Servlet APIs

Application services must be transport-agnostic and persistence-agnostic.

### API Layer (api/)

- Controllers, DTOs, HTTP-specific concerns.
- Controller flow must ALWAYS be:
  DTO → mapper → domain command → service → domain result → mapper → DTO.
- Controllers handle cookies, headers, status codes.
- DTOs never leak outside this layer.
- No domain logic inside controllers.

### Infra Layer (infra/)

- Persistence implementations (JDBC or JPA).
- Mappers converting Entity ↔ Domain.
- External API clients.
- Security utilities.
- No domain logic.
- No DTO logic.

## 2. Auth Module Rules

Cursor must enforce the following patterns:

### Commands (Domain)

- All incoming write operations must use domain-level command objects.
  Example: LoginCommand, RegisterCommand, RefreshCommand.

### Results (Domain)

- All outcomes returned by services must be domain result objects.
  Example: AuthResult.

### Service Layer must NEVER use HttpServletResponse/Request

- Cookie setting and all HTTP concerns belong in the controller only.

### Service Layer must NEVER take primitives from controllers

- Controllers must convert DTO → Domain before calling service.

### Service Layer must NEVER return DTOs

- Must return domain results only.

### Controller must set refresh token cookie (not the service)

### Service must only generate refresh token VALUE.

- Controller writes it to cookie.
- Service must not modify HTTP headers.

## 3. Persistence Rules

- Domain repositories define interfaces only.
- Infra repositories implement them via JDBC or JPA.
- Entities must never leak into domain or application layer.
- Mappers must be used for:
  - DTO ↔ Domain (API layer)
  - Entity ↔ Domain (Infra layer)

## 4. Fix ALL existing Auth flows

Cursor must refactor:

- register()
- refresh()
- logout()

to follow the same pattern as the clean login flow.

Changes required:

- Extract domain-level commands where appropriate.
- Services must accept only domain objects or primitives if domain says so.
- Services must return AuthResult or domain equivalents.
- All cookie writing must move into controllers.
- Service must generate refresh token but not set cookies.
- Ensure mappers are created where needed.

## 5. Future Code Generation Rules

Cursor must NOT generate:

- @Entity or JPA annotations in domain.
- DTOs in domain or application layers.
- HttpServletResponse/Request in services.
- Services accepting request DTOs.
- Services returning DTOs.
- Controllers passing primitives directly into services.
- Controllers returning domain objects to HTTP layer.

Cursor must ALWAYS generate:

- Pure domain commands and results.
- Domain → API → Domain mapping layers.
- Transport-agnostic application services.
- Proper repository interfaces in domain.
- Proper repository implementations in infra.
- Correct folder structure per layer.

## 6. Safety rule

If Cursor detects any ambiguity (domain missing, unclear boundaries), it must ask for clarification before generating code.

---
