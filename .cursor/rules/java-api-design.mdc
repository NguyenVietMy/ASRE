---
alwaysApply: true
---

# Java API Design (DDD Architecture Rule)

You must generate all Java code following the Domain-Driven API structure below.  
Do **not** expose JPA entities.  
Do **not** mix persistence concerns into domain models.

Your job is to always transform user requests into the following architecture:

---

# 1. DOMAIN LAYER (Pure Business Model)

Create **pure domain objects** with:

- No `@Entity`, no JPA annotations
- Business invariants
- Behavior methods (not just getters/setters)

## Example Structure

```java
package com.example.domain.campaign;

import java.time.LocalDateTime;
import java.util.UUID;

public class Campaign {

    private UUID id;
    private UUID orgId;
    private Long createdBy;
    private String name;
    private String description;
    private CampaignStatus status;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public enum CampaignStatus { ACTIVE, PAUSED, COMPLETED, INACTIVE }

    // Behavior
    public void pause() {
        if (status == CampaignStatus.ACTIVE) {
            status = CampaignStatus.PAUSED;
        }
    }

    public void complete() {
        status = CampaignStatus.COMPLETED;
    }

    // Constructors + getters/setters as needed
}
Domain ≠ Persistence.

2. PERSISTENCE LAYER (JPA Entity Representation Only)
Entities must only store data, never business logic.

java
Copy code
package com.example.infra.jpa.campaign;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "campaigns")
public class CampaignEntity {

    @Id
    private UUID id;
    private UUID orgId;
    private Long createdBy;
    private String name;
    private String description;

    @Enumerated(EnumType.STRING)
    private CampaignStatus status;

    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
3. MAPPER (Transforms Entity ↔ Domain)
Always create a mapper layer to decouple JPA from domain logic.

java
Copy code
package com.example.infra.jpa.campaign;

import org.springframework.stereotype.Component;
import com.example.domain.campaign.Campaign;

@Component
public class CampaignEntityMapper {

    public CampaignEntity toEntity(Campaign domain) {
        CampaignEntity entity = new CampaignEntity();
        entity.setId(domain.getId());
        entity.setOrgId(domain.getOrgId());
        entity.setCreatedBy(domain.getCreatedBy());
        entity.setName(domain.getName());
        entity.setDescription(domain.getDescription());
        entity.setStatus(domain.getStatus());
        entity.setCreatedAt(domain.getCreatedAt());
        entity.setUpdatedAt(domain.getUpdatedAt());
        return entity;
    }

    public Campaign toDomain(CampaignEntity entity) {
        Campaign domain = new Campaign();
        domain.setId(entity.getId());
        domain.setOrgId(entity.getOrgId());
        domain.setCreatedBy(entity.getCreatedBy());
        domain.setName(entity.getName());
        domain.setDescription(entity.getDescription());
        domain.setStatus(entity.getStatus());
        domain.setCreatedAt(entity.getCreatedAt());
        domain.setUpdatedAt(entity.getUpdatedAt());
        return domain;
    }
}
4. REPOSITORY INTERFACE (Domain-Driven)
Define it in domain layer, not tied to JPA.

java
Copy code
package com.example.domain.campaign;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

public interface CampaignRepository {
    Campaign save(Campaign campaign);
    Optional<Campaign> findById(UUID id);
    List<Campaign> findAllByOrgId(UUID orgId);
}
5. JPA IMPLEMENTATION (infra layer)
java
Copy code
package com.example.infra.jpa.campaign;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import com.example.domain.campaign.*;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
@RequiredArgsConstructor
public class JpaCampaignRepository implements CampaignRepository {

    private final SpringDataCampaignRepository jpaRepo;
    private final CampaignEntityMapper mapper;

    @Override
    public Campaign save(Campaign campaign) {
        CampaignEntity entity = mapper.toEntity(campaign);
        return mapper.toDomain(jpaRepo.save(entity));
    }

    @Override
    public Optional<Campaign> findById(UUID id) {
        return jpaRepo.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    public List<Campaign> findAllByOrgId(UUID orgId) {
        return jpaRepo.findAllByOrgId(orgId)
                .stream()
                .map(mapper::toDomain)
                .toList();
    }
}
6. APPLICATION SERVICES (Use Cases)
Contains orchestration logic only — not HTTP, not JPA.

java
Copy code
package com.example.application.campaign;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import com.example.domain.campaign.*;

import java.util.UUID;

@Service
@RequiredArgsConstructor
public class CampaignService {

    private final CampaignRepository campaignRepository;

    public Campaign createCampaign(Campaign newCampaign) {
        newCampaign.setStatus(Campaign.CampaignStatus.ACTIVE);
        return campaignRepository.save(newCampaign);
    }

    public Campaign pauseCampaign(UUID id) {
        Campaign campaign = campaignRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Campaign not found"));
        campaign.pause();
        return campaignRepository.save(campaign);
    }
}
7. PRESENTATION LAYER (Controllers + DTOs)
java
Copy code
package com.example.api.campaign;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import com.example.application.campaign.CampaignService;
import com.example.domain.campaign.Campaign;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/campaigns")
public class CampaignController {

    private final CampaignService service;
    private final CampaignDtoMapper mapper;

    @PostMapping
    public CampaignResponse create(@RequestBody CreateCampaignRequest request) {
        Campaign domain = mapper.toDomain(request);
        Campaign saved = service.createCampaign(domain);
        return mapper.toResponse(saved);
    }
}
RULE SUMMARY
You must always structure code like this when generating Java backend:

Domain model
pure class, fields + behavior

Entity
JPA only

Mapper
Domain ↔ Entity

Repository interface
declared in domain

Repository implementation
lives in infra

Service
coordinates domain logic

Controller + DTOs
presentation layer only
```
